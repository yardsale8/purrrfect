% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/replicate.R
\name{replicate}
\alias{replicate}
\alias{replicate_lgl}
\alias{replicate_int}
\alias{replicate_dbl}
\alias{replicate_chr}
\alias{replicate_vec}
\alias{replicate2}
\alias{replicate2_lgl}
\alias{replicate2_int}
\alias{replicate2_dbl}
\alias{replicate2_chr}
\alias{replicate2_vec}
\title{A Better \code{replicate}}
\usage{
replicate(
  n,
  expr,
  .reshape = NULL,
  names_sep = ".",
  transform = NULL,
  .as = .outcome
)

replicate_lgl(n, expr, .as = .outcome)

replicate_int(n, expr, .as = .outcome)

replicate_dbl(n, expr, .as = .outcome)

replicate_chr(n, expr, .as = .outcome)

replicate_vec(n, expr, .as = .outcome)

replicate2(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)

replicate2_lgl(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)

replicate2_int(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)

replicate2_dbl(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)

replicate2_chr(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)

replicate2_vec(n, expr1, expr2, .as1 = .outcome1, .as2 = .outcome2)
}
\arguments{
\item{n}{The number of replications.}

\item{expr}{The expression to replicates.}
}
\value{
A \code{tibble} containing the results in a field names \code{.outcome}, along with a \code{.trial} field containing the replication number.
}
\description{
The function \code{replicate}, along with the family of \verb{replicate_*}
functions, are meant replace \code{base::replicate}
\itemize{
\item \code{replicate()} always returns the output in a list column.
\item \code{replicate_lgl()} , \code{replicate_int()} , \code{replicate_dbl()} and \code{replicate_chr()} use the \verb{map_*} functions from \code{purrr} to return an atomic vector of the indicated type (or die trying). For these functions, \code{expr} must return a length-1 vector of the appropriate type.
\item \code{replicate_vec()} uses \code{purrr::map_vec} to simplifies to the common type of the output. It works with most types of simple vectors like Date, POSIXct, factors, etc.
}
}
\details{
The output of \code{base::replicate} (with default parameters) is tricky
to use: The returned object is either a vector or list, depending on if the
\code{expr} generates an atomic element or vector/list, respectively.
Consequently, you need to transpose the matrix before converting to a \code{data.frame}
for expressions that result in a vector/list.

On the other hand, this suite of functions returns a \code{tibble} containing
the results (as a list column), along with a \code{.trial} field.

Similar to \code{base::replicate} the \code{expr} re-evaluated on each trial,
e.g., to facilitate replicating expressions with random output.
}
\examples{
library(dplyr)
# Use `replicate` to put compound output in a list column
out <- replicate(10, sample(x = c('H', 'T'), size = 5, replace = TRUE))
str(out)
glimpse(out)

# Use `replicate_*` to specify the output for simple expression returning a single object
out <- replicate_int(10, rbinom(1, 5, 0.5))
str(out)
glimpse(out)

# Use `replicate_vec` to specify the output for expressions returning simple vectors like Date, POSIXct, factors, etc.
out <- replicate_vec(10, as.Date("01-01-01"))
str(out)
glimpse(out)
}
